/**
 * Client-Side Balance Proof Generator
 *
 * This module generates ZK proofs that prove a user has sufficient balance
 * to place an order, WITHOUT revealing their actual balance.
 *
 * The proof is generated entirely in the browser - the relay never sees:
 * - User's secret
 * - User's total balance
 * - Which deposit note they're spending
 *
 * Flow:
 * 1. User has a "spending note" from a previous deposit
 * 2. User wants to place an order
 * 3. This module generates a ZK proof that: balance >= order_amount
 * 4. Proof is sent to relay alongside Arcium-encrypted order
 */

// @ts-ignore - Noir WASM imports
import { Noir } from '@noir-lang/noir_js';
// @ts-ignore - UltraHonk backend
import { UltraHonkBackend } from '@aztec/bb.js';
// Poseidon hash - MUST match Noir circuit's poseidon::bn254::hash_2 and hash_3
import { poseidon2, poseidon3 } from 'poseidon-lite';

/**
 * Spending note - user keeps this private after depositing
 */
export interface SpendingNote {
  /** Random secret chosen at deposit time */
  secret: bigint;
  /** Amount in micro-USDC (6 decimals) */
  amount: bigint;
  /** Index of commitment in Merkle tree */
  leafIndex: number;
  /** The commitment hash (public, in tree) */
  commitment: string;
}

/**
 * Inputs needed to generate a balance proof
 */
export interface BalanceProofInputs {
  /** User's spending note */
  note: SpendingNote;
  /** Order amount in micro-USDC */
  orderAmount: bigint;
  /** Current Merkle root (fetch from chain) */
  merkleRoot: string;
  /** Merkle path for the note's commitment */
  merklePath: string[];
}

/**
 * Output of proof generation
 */
export interface BalanceProofOutput {
  /** The ZK proof (send to relay) */
  proof: Uint8Array;
  /** Public inputs that relay verifies */
  publicInputs: {
    merkleRoot: string;
    nullifier: string;
    newCommitment: string;
    orderCommitment: string;
  };
  /** New spending note for remaining balance */
  changeNote: SpendingNote | null;
}

// Circuit artifact (compiled Noir circuit)
let circuitArtifact: any = null;
let backend: UltraHonkBackend | null = null;
let noir: Noir | null = null;

/**
 * Initialize the prover (load circuit, setup backend)
 * Call this once when app loads
 */
export async function initializeProver(): Promise<void> {
  console.log('[BalanceProver] Initializing...');

  // Load compiled circuit (generated by `nargo compile`)
  const response = await fetch('/circuits/balance_proof.json');
  circuitArtifact = await response.json();

  // Initialize UltraHonk backend
  backend = new UltraHonkBackend(circuitArtifact.bytecode);

  // Initialize Noir
  noir = new Noir(circuitArtifact);

  console.log('[BalanceProver] Ready');
}

/**
 * Generate a balance proof
 *
 * This proves: "I have a valid note with balance >= orderAmount"
 * Without revealing: actual balance, which note, or my identity
 */
export async function generateBalanceProof(
  inputs: BalanceProofInputs
): Promise<BalanceProofOutput> {
  if (!noir || !backend) {
    throw new Error('Prover not initialized. Call initializeProver() first.');
  }

  const { note, orderAmount, merkleRoot, merklePath } = inputs;

  // Validate inputs
  if (orderAmount > note.amount) {
    throw new Error(`Insufficient balance: have ${note.amount}, need ${orderAmount}`);
  }

  console.log('[BalanceProver] Generating proof...');
  console.log(`[BalanceProver] Balance: ${note.amount}, Order: ${orderAmount}`);

  // Generate random values
  const orderSalt = generateRandomField();
  const newSecret = generateRandomField();

  // Compute derived values
  const nullifier = poseidonHash([note.secret, BigInt(note.leafIndex), 1n]);
  const orderCommitment = poseidonHash([orderAmount, orderSalt]);
  const remainingAmount = note.amount - orderAmount;
  const newCommitment = poseidonHash([newSecret, remainingAmount]);

  // Prepare circuit inputs
  const circuitInputs = {
    // Public inputs
    merkle_root: merkleRoot,
    nullifier: fieldToHex(nullifier),
    new_commitment: fieldToHex(newCommitment),
    order_commitment: fieldToHex(orderCommitment),

    // Private inputs
    old_secret: note.secret.toString(),
    old_amount: note.amount.toString(),
    leaf_index: note.leafIndex.toString(),
    merkle_path: merklePath,
    order_amount: orderAmount.toString(),
    order_salt: orderSalt.toString(),
    new_secret: newSecret.toString(),
  };

  // Generate witness
  const { witness } = await noir.execute(circuitInputs);

  // Generate proof
  const proof = await backend.generateProof(witness);

  console.log('[BalanceProver] Proof generated!');

  // Create change note if there's remaining balance
  let changeNote: SpendingNote | null = null;
  if (remainingAmount > 0n) {
    changeNote = {
      secret: newSecret,
      amount: remainingAmount,
      leafIndex: -1, // Will be set when commitment is added to tree
      commitment: fieldToHex(newCommitment),
    };
  }

  return {
    proof: proof.proof,
    publicInputs: {
      merkleRoot,
      nullifier: fieldToHex(nullifier),
      newCommitment: fieldToHex(newCommitment),
      orderCommitment: fieldToHex(orderCommitment),
    },
    changeNote,
  };
}

/**
 * Verify a balance proof (usually done by relay, but can verify locally)
 */
export async function verifyBalanceProof(
  proof: Uint8Array,
  publicInputs: string[]
): Promise<boolean> {
  if (!backend) {
    throw new Error('Prover not initialized');
  }

  return await backend.verifyProof({
    proof,
    publicInputs,
  });
}

// ============================================
// HELPERS
// ============================================

/**
 * Generate a random field element
 */
function generateRandomField(): bigint {
  const bytes = new Uint8Array(32);
  crypto.getRandomValues(bytes);
  // Reduce to field size (BN254 scalar field)
  const BN254_ORDER = 21888242871839275222246405745257275088548364400416034343698204186575808495617n;
  let value = 0n;
  for (const byte of bytes) {
    value = (value << 8n) | BigInt(byte);
  }
  return value % BN254_ORDER;
}

/**
 * Poseidon hash - matches Noir circuit's poseidon::bn254::hash_2 and hash_3
 * Uses poseidon-lite which implements the same Poseidon parameters as Noir
 */
function poseidonHash(inputs: bigint[]): bigint {
  if (inputs.length === 2) {
    return poseidon2(inputs);
  }
  if (inputs.length === 3) {
    return poseidon3(inputs);
  }
  throw new Error(`Unsupported Poseidon input count: ${inputs.length}. Only 2 or 3 inputs supported.`);
}

/**
 * Convert bigint field to hex string
 */
function fieldToHex(value: bigint): string {
  return '0x' + value.toString(16).padStart(64, '0');
}

/**
 * Convert hex string to bigint
 */
function hexToField(hex: string): bigint {
  return BigInt(hex);
}

// ============================================
// SPENDING NOTE MANAGEMENT
// ============================================

const NOTES_STORAGE_KEY = 'obsidian_spending_notes';

/**
 * Save spending notes to localStorage (encrypted in production!)
 */
export function saveSpendingNotes(notes: SpendingNote[]): void {
  // WARNING: In production, encrypt these with user's wallet signature
  const serialized = notes.map(note => ({
    secret: note.secret.toString(),
    amount: note.amount.toString(),
    leafIndex: note.leafIndex,
    commitment: note.commitment,
  }));
  localStorage.setItem(NOTES_STORAGE_KEY, JSON.stringify(serialized));
}

/**
 * Load spending notes from localStorage
 */
export function loadSpendingNotes(): SpendingNote[] {
  const stored = localStorage.getItem(NOTES_STORAGE_KEY);
  if (!stored) return [];

  const parsed = JSON.parse(stored);
  return parsed.map((note: any) => ({
    secret: BigInt(note.secret),
    amount: BigInt(note.amount),
    leafIndex: note.leafIndex,
    commitment: note.commitment,
  }));
}

/**
 * Create a new spending note for a deposit
 */
export function createSpendingNote(amount: bigint): {
  note: SpendingNote;
  commitment: string;
} {
  const secret = generateRandomField();
  const commitment = poseidonHash([secret, amount]);

  const note: SpendingNote = {
    secret,
    amount,
    leafIndex: -1, // Set after deposit tx confirms
    commitment: fieldToHex(commitment),
  };

  return { note, commitment: fieldToHex(commitment) };
}

/**
 * Find a note with sufficient balance for an order
 */
export function findNoteForOrder(
  notes: SpendingNote[],
  orderAmount: bigint
): SpendingNote | null {
  // Find smallest note that covers the order (minimize change)
  const validNotes = notes
    .filter(n => n.amount >= orderAmount && n.leafIndex >= 0)
    .sort((a, b) => Number(a.amount - b.amount));

  return validNotes[0] || null;
}
